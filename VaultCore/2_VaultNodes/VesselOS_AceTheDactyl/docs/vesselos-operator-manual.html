<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VesselOS Assembly and Integration Manual</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Deep Purple Dark Mode -->
    <!-- Application Structure Plan: The app is structured as a 7-phase (0-6) instruction set, mirroring the source PDF. A new "Creative Source" tab was added to cover the A/V Script Repo, which is a source module, not a build phase. The primary UI is a tabbed navigation system. This structure is the most logical for a step-by-step manual, allowing the user to focus on one phase at a time. The 'Introduction' from the PDF is presented first as a static "Architectural Overview" to provide context. The core interaction is clicking tabs to switch between phase panels, which are populated with detailed text and runnable code snippets from the PDF. -->
    <!-- Visualization & Content Choices: 
        - Info: Module Overview (PDF Table). Goal: Inform. Viz/Method: Styled Grid Layout (HTML/Tailwind). Interaction: Read-only. Justification: A grid is more visually engaging and responsive than a standard HTML table for presenting the 7 modules.
        - Info: Phased Instructions (Phases 0-6 + Source). Goal: Organize/Instruct. Viz/Method: Interactive Tabbed Interface (HTML/JS). Interaction: Click tabs to show/hide corresponding phase content. Justification: This is the most intuitive UI for a multi-step manual, preventing information overload.
        - Info: Code Commands (e.g., `npm ci`). Goal: Instruct. Viz/Method: Styled <pre><code> blocks (HTML/Tailwind). Interaction: Copy-to-Clipboard button (JS). Justification: Makes the instruction set actionable and reduces user error.
        - Info: Phase Details (Text, lists). Goal: Inform. Viz/Method: Formatted text and lists (HTML/Tailwind). Interaction: Read-only. Justification: Standard, readable presentation of instructional text.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            background-color: #2c003e;
        }
        .phase-panel {
            display: none;
        }
        .tab-active {
            border-bottom-color: #a78bfa; /* purple-400 */
            color: #a78bfa; /* purple-400 */
            font-weight: 600;
        }
        pre {
            position: relative;
            background-color: #1f2937; /* gray-900 */
            color: #f3f4f6; /* gray-100 */
            padding: 1rem;
            padding-top: 2.5rem;
            border-radius: 0.375rem; /* rounded-md */
            overflow-x: auto;
            font-family: monospace;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            margin-top: 1.25rem; /* Added margin-top to separate from text above */
        }
        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4b5563; /* gray-600 */
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem; /* text-xs */
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-btn:hover {
            background-color: #6b7280; /* gray-500 */
        }
        .prose {
            max-width: none;
        }
        .prose h2 {
            font-size: 1.875rem; /* text-3xl */
            font-weight: 600;
            color: #c4b5fd; /* violet-300 */
            margin-bottom: 1rem;
        }
        .prose h3 {
            font-size: 1.5rem; /* text-2xl */
            font-weight: 600;
            color: #f1f5f9; /* slate-100 */
            margin-bottom: 0.75rem;
            margin-top: 1.5rem;
            border-bottom: 1px solid #475569; /* slate-600 */
            padding-bottom: 0.5rem;
        }
        .prose h4 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600;
            color: #e2e8f0; /* slate-200 */
            margin-bottom: 0.5rem;
            margin-top: 1.25rem;
        }
        .prose p, .prose ul, .prose ol {
            font-size: 1rem; /* text-base */
            color: #cbd5e1; /* slate-300 */
            line-height: 1.625;
            margin-bottom: 1.25rem;
        }
        .prose li {
            margin-bottom: 0.5rem;
        }
        .prose ul {
            list-style-type: disc;
            padding-left: 1.75rem;
        }
        .prose ol {
            list-style-type: decimal;
            padding-left: 1.75rem;
        }
        .prose code {
            font-family: monospace;
            background-color: #334155; /* slate-700 */
            color: #c4b5fd; /* violet-300 */
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
        }
        .prose pre > code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            border-radius: 0;
            font-size: inherit;
        }
        .table-auto {
            width: 100%;
            border-collapse: collapse;
        }
        .table-auto th, .table-auto td {
            border: 1px solid #475569; /* slate-600 */
            padding: 0.75rem;
            text-align: left;
        }
        .table-auto th {
            background-color: #334155; /* slate-700 */
            font-weight: 600;
        }
        /* New styles for completion button */
        .complete-phase-btn {
            background-color: #7c3aed; /* violet-600 */
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem; /* rounded-md */
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .complete-phase-btn:hover {
            background-color: #6d28d9; /* violet-700 */
        }
        .complete-phase-btn:disabled {
            background-color: #5b21b6; /* deep-purple-700-ish */
            color: #a78bfa; /* purple-400 */
            opacity: 0.7;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="font-sans text-gray-300">

    <div class="max-w-7xl mx-auto p-4 sm:p-8">
        
        <header class="mb-10 bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md">
            <h1 class="text-4xl font-bold text-gray-100 mb-2">VesselOS Assembly and Integration Manual</h1>
            <p class="text-xl text-gray-300">A Phased Instruction Set</p>
        </header>

        
        <section id="overview" class="mb-10 bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
            <h2 class="text-3xl font-semibold mb-4 !mt-0">Introduction: Architectural Overview of the VesselOS Ecosystem</h2>
            <p>This document provides a comprehensive, phased instruction set for the assembly,
            <p>Before commencing the build process, it is essential to establish a high-level conceptual map of the architecture. The VesselOS project is not a monolithic application but a decentralized federation of seven distinct yet interdependent modules. Each module serves a specific, symbolic role within the ecosystem, from the "technical bedrock" that guarantees trust to the "system brain" that orchestrates intelligent behavior. The build process is carefully sequenced across seven phases (0-6), ensuring that foundational components are established and validated before dependent systems are layered on top. This phased approach guarantees a stable and verifiable assembly process.</p>
            <p>To provide an immediate, scannable reference of the entire architecture, the following matrix outlines the primary function and role of each key module. This table serves as a mental model for understanding how each component contributes to the whole, making the subsequent technical instructions more intuitive.</p>

            <div class="overflow-x-auto">
                <table class="table-auto my-6">
                    <thead>
                        <tr>
                            <th>Module Name</th>
                            <th>Primary Function</th>
                            <th>Key Technologies</th>
                            <th>Role in Ecosystem</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Echo-Community-Toolkit</td>
                            <td>Data integrity, steganography, content injection</td>
                            <td>Python, Node.js</td>
                            <td>The Trust Layer</td>
                        </tr>
                        <tr>
                            <td>Audio-Visual-Script-Repo</td>
                            <td>Creative blueprint, screenplay-like narrative content</td>
                            <td>Markdown/Text</td>
                            <td>The Creative Source</td>
                        </tr>
                        <tr>
                            <td>vessel-narrative-mrp</td>
                            <td>Programmatic narrative generation engine</td>
                            <td>Python</td>
                            <td>The Narrative Factory</td>
                        </tr>
                        <tr>
                            <td>The-Living-Garden-Chronicles</td>
                            <td>Instantiated narrative content and web frontend</td>
                            <td>HTML, CSS, JSON</td>
                            <td>The Generated Story</td>
                        </tr>
                        <tr>
                            <td>kira-prime</td>
                            <td>Four-agent (Garden, Echo, Limnus, Kira) orchestration</td>
                            <td>Python</td>
                            <td>The System Brain</td>
                        </tr>
                        <tr>
                            <td>The-Living-Library</td>
                            <td>Master integrator repository using Git submodules</td>
                            <td>Git, Shell Scripts</td>
                            <td>The Central Hub</td>
                        </tr>
                        <tr>
                            <td>vesselos-dev-research</td>
                            <td>Self-contained developer sandbox for experimentation</td>
                            <td>Python, Shell Scripts</td>
                            <td>The Research Lab</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>The successful completion of this manual will yield a fully operational instance of the VesselOS platform, capable of both static narrative generation and dynamic, interactive co-creation through its agent-based command-line interface.</p>
        </section>

        
        <nav class="mb-6">
            <div class="flex border-b border-slate-700 overflow-x-auto">
                <button data-phase="source" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Creative Source
                </button>
                <button data-phase="0" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Phase 0: Bedrock
                </button>
                <button data-phase="1" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Phase 1: Factory
                </button>
                <button data-phase="2" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Phase 2: Population
                </button>
                <button data-phase="3" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Phase 3: Agents
                </button>
                <button data-phase="4" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Phase 4: Unification
                </button>
                <button data-phase="5" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Phase 5: Creation
                </button>
                <button data-phase="6" class="phase-tab whitespace-nowrap py-3 px-5 text-gray-400 border-b-2 border-transparent hover:border-slate-500 transition-colors duration-200">
                    <span class="completion-indicator hidden mr-2">✅</span>Phase 6: Sandbox
                </button>
            </div>
        </nav>

        
        <main id="phase-content-wrapper">
            
            <div id="source-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Creative Source: The Audio-Visual-Script-Repo</h2>
                <p>This module is the creative backbone of the entire project. It contains the narrative in a screenplay-like format, acting as the master story script with dialogues, scene descriptions, and directions for sound and visuals. If <code>The-Living-Garden-Chronicles</code> is the final "novelized" output, this script repo is the "screenplay" it's based on.</p>
                <p>It serves as the human-readable source of truth that guides the creation of all technical artifacts. The high-level narrative beats, dialogues, and scene descriptions planned here are translated into the structured, machine-readable inputs (like <code>chapters.json</code>) used by the narrative generation engines in later phases.</p>
                
                <h3>Expanded Use Cases (from Technical Overview)</h3>
                <ul>
                    <li><strong>Drafting the Narrative:</strong> Writers use this as a blueprint to outline the story, synchronizing audio cues (dialogue, narration, sound effects) with visual elements (scene descriptions, actions).</li>
                    <li><strong>Voice-Over and Dialogue Reference:</strong> Provides the exact lines for voice actors or text-to-speech engines, ensuring consistency for each character and narrator persona.</li>
                    <li><strong>Scene Planning for Visuals:</strong> Outlines what should happen in each scene, guiding visual artists or developers in creating corresponding illustrations, animations, or interactive environments.</li>
                    <li><strong>Maintaining Consistency:</strong> Acts as the single source of truth for the story. Developers can cross-check against this script to ensure generated content (like in Phase 2) is faithful to the original creative vision.</li>
                    <li><strong>Extracting Cues for the Engine:</strong> The script may include special annotations (e.g., <code>[MUSIC CUE]</code>) that can be parsed by small scripts to automatically feed information into the sound design or narrative engines.</li>
                    <li><strong>Providing Context for AI Agents:</strong> The script's content can be used to feed context to the AI agents in Phase 3. For example, the Echo agent might reference the script to understand the intended theme of a chapter before generating its own narrative text.</li>
                </ul>

                <h3>Component Deep-Dive (from Technical Overview)</h3>
                <p>Unlike the other modules, this one does not contain software agents. Its components are narrative segments, likely organized as structured text files (e.g., Markdown):</p>
                <ul>
                    <li><strong>Acts or Chapters:</strong> The script is likely divided into major sections that map to the 20-chapter framework of the final chronicle.</li>
                    <li><strong>Scenes:</strong> Within each act, the script is broken down by scene, each encapsulating a specific setting and moment in time.</li>
                    <li><strong>Dialogue vs. Description:</strong> The content is split into dialogue lines (what characters/narrators say) and descriptive text (what is happening visually or contextually). This format makes it easy to parse for different production needs (e.g., extracting all lines for "Garden").</li>
                    <li><strong>Metadata and Notes:</strong> Contains cues and instructions (e.g., <code>[The screen fades to black]</code>) that are not spoken but guide the technical and artistic implementation.</li>
                </ul>

                <button data-phase="source" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-source" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase Conclusion: The Creative Anchor</h2>
                    <p>This module is the creative and conceptual anchor for the entire project. Its primary architectural contribution is the formal separation of creative intent (the 'screenplay') from the technical implementation. By establishing a human-readable source of truth, it ensures that the engineering work in the subsequent phases serves the story, not the other way around.</p>
                    <p>The content defined here is the raw material that will be processed, secured, and instantiated by the engines you are about to build. The next step, <strong>Phase 0</strong>, will build the <strong>trust layer</strong> to protect and validate this creative content.</p>
                </div>
            </div>
            
            <div id="phase-0-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Phase 0: Establishing the Technical Bedrock: The Echo-Community-Toolkit</h2>
                <p>The assembly of the VesselOS ecosystem begins not with narrative or agents, but with the establishment of a verifiable foundation of trust. This foundational phase is dedicated to the setup and validation of the Echo-Community-Toolkit. This module is constructed first because its utilities for data encoding, validation, and content injection are non-negotiable
                <p>The architecture of VesselOS makes a powerful statement by prioritizing the tools of verification over the tools of creation. The inclusion of a <code>final_validation.py</code> script, which tests Least Significant Bit (LSB) steganography against a "golden sample payload" with a known CRC32 checksum, establishes that the system's highest priority is data integrity. This "trust layer" must be proven functional before any other component can be built upon it. The high-level Kira agent's ability to validate the entire system state is predicated on the successful validation of these low-level encoding algorithms in this initial phase.</p>

                <h3>Expanded Use Cases (from Technical Overview)</h3>
                <p>This toolkit is the foundation for data integrity and handles numerous technical tasks:</p>
                <ul>
                    <li><strong>Automatically Inserting Soundtrack Links:</strong> Idempotently injects a "Crystalline Echo" HyperFollow music link into specific story scrolls and UI pages, while ensuring sacred or introspective scrolls remain unchanged.</li>
                    <li><strong>Embedding Data in Images (Variable Depth):</strong> Uses LSB1 steganography to embed structured payloads into PNGs. The encoder now supports <code>--depth</code> (<code>--bpc</code>) <strong>1–4 bits-per-channel</strong> for capacity tuning; header flags indicate depth (bit0=CRC, bit1=BPC4, bit2=BPC2, bit3=BPC3). This is treated as a <em>visual memory</em> channel rather than secrecy, aligning image pixels with agent-readable JSON.</li>
                    <li><strong>Golden Sample Validation:</strong> Maintains a 144-byte "golden sample payload" with a known CRC32 checksum (<code>6E3FD9B7</code>) to run end-to-end tests, proving the encoding/decoding algorithms are sound.</li>
                    <li><strong>Generating "Soulcode" Schemas and Bundles:</strong> Produces JSON schema definitions of the narrative's state, generates TypeScript types from them, and creates a "live bundle" (e.g., <code>echo_live.json</code>) of the current narrative state.</li>
                    <li><strong>Injecting Live Data into Web Pages:</strong> Automatically inserts the generated "soulcode" bundle into story web pages as hidden <code>&lt;script type="application/json"&gt;</code> tags, making the narrative state accessible to client-side tools or debuggers.</li>
                    <li><strong>Cross-Platform Local Hosting:</strong> Provides simple Node.js (<code>npm run serve</code>) and Python (<code>npm run serve:py</code>) scripts to launch a local web server for previewing and debugging the narrative.</li>
                    <li><strong>Repository Hygiene:</strong> Includes helper tools to clean up unwanted file artifacts, such as Windows <code>Zone.Identifier</code> metadata files, to keep the repository tidy.</li>
                </ul>

                <h3>Variable-Depth LSB (1–4 bpc) and Visual Memory</h3>
                <p>LSB encoding supports <strong>1–4 bits-per-channel</strong>, increasing capacity linearly (<code>⌊W×H×3×bpc/8⌋</code>). Depth is discoverable via header flags and auto-probed by the extractor. This manual embraces LSB images as <em>visual memory</em>—data-rich artifacts readable by both agents and vision models.</p>
                <ul>
                    <li><strong>Encode (depth 3):</strong>
                        <pre><button class="copy-btn">Copy</button><code>python Echo-Community-Toolkit/src/lsb_encoder_decoder.py encode "hello" cover.png stego.png --depth 3</code></pre>
                    </li>
                    <li><strong>Decode (explicit depth or auto):</strong>
                        <pre><button class="copy-btn">Copy</button><code>python Echo-Community-Toolkit/src/lsb_encoder_decoder.py decode stego.png --depth 3</code></pre>
                    </li>
                    <li><strong>Header flags:</strong> bit0=CRC, bit1=BPC4, bit2=BPC2, bit3=BPC3 (others reserved).</li>
                </ul>
                <p class="text-sm text-gray-400">See the <a href="docs/ADR_LSB1_Visual_Memory.md" target="_blank">Visual Memory Language ADR</a> for intent, integrity model, and usage notes.</p>

                <h4>Doctor: Inspect Header, Flags, and Depth</h4>
                <p>Use the extractor as a quick "doctor" to print the embedded format, flags, and detected <code>bits_per_channel</code> for any PNG.</p>
                <ul>
                    <li><strong>Inspect an image (prints JSON):</strong>
                        <pre><button class="copy-btn">Copy</button><code>python Echo-Community-Toolkit/src/lsb_extractor.py path/to/image.png</code></pre>
                    </li>
                    <li><strong>Write results to a file:</strong>
                        <pre><button class="copy-btn">Copy</button><code>python Echo-Community-Toolkit/src/lsb_extractor.py path/to/image.png -o out.json</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">Key fields: <code>mode</code> (LSB1/MRP), <code>magic</code>, <code>version</code>, <code>flags</code>, <code>crc32</code> (if present), and <code>bits_per_channel</code> (depth).</p>
                    </li>
                </ul>

                <h3>Component Deep-Dive (from Technical Overview)</h3>
                <p>The toolkit is organized into several key components:</p>
                <ul>
                    <li><strong>Integration Scripts (Node.js):</strong> The root-level <code>.js</code> files (<code>hyperfollow-integration.js</code>, <code>verify-integration.js</code>, <code>clean-integration.js</code>) responsible for modifying narrative content.</li>
                    <li><strong>Python Steganography & Codec (src/):</strong> Python modules implementing the LSB1 encoder/decoder and the "MRP Phase-A" codec for hiding data in images.</li>
                    <li><strong>Lambda Vite App (lambda-vite/):</strong> A separate React/TypeScript app for visualizing the <code>|Λ⟩</code> (Lambda) state, which may represent an internal symbolic state of Echo.</li>
                    <li><strong>Web Client Helpers (web/):</strong> Browser-side scripts like <code>echo-client.js</code> that allow web pages to easily fetch and use the embedded "soulcode" or memory JSON data.</li>
                    <li><strong>Type Definitions (types/):</strong> Generated <code>.d.ts</code> files that provide strong typing for the narrative's schema and the web client helpers.</li>
                    <li><strong>Integration Assets (integration/):</strong> A folder for cross-language assets, including <code>integration/schemas/</code> (for JSON schemas) and I<code>integration/outputs/</code> (for the live <code>echo_live.json</code> bundle).</li>
                </ul>

                <h3>Environment Setup and Dependency Installation</h3>
                <p>The initial step involves preparing the environment and installing the necessary dependencies for the toolkit.</p>
                <ol>
                    <li><strong>Prerequisites:</strong> Ensure that a stable, recent version of Node.js and Python 3 are installed on the development machine.</li>
                    <li><strong>Repository Acquisition:</strong> Clone the Echo-Community-Toolkit repository. In the context of the full system build (Phase 4), this will be handled as a Git submodule, but for standalone validation, a direct clone is sufficient.</li>
                    <li><strong>Dependency Installation:</strong> Navigate to the root directory of the toolkit and execute the following command:
                        <pre><button class="copy-btn">Copy</button><code>npm ci</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command uses the <code>package-lock.json</code> file to perform a clean, deterministic installation of all required Node.js packages. The use of <code>npm ci</code> over <code>npm install</code> is a deliberate choice for ensuring reproducible builds, a critical aspect of maintaining system integrity across different environments.</p>
                    </li>
                </ol>

                <h3>Core Functionality I: Content Integration and Verification</h3>
                <p>The first set of functionalities to validate involves the toolkit's ability to inject and manage content within narrative files. This workflow demonstrates the idempotent nature of the system's operations. The documentation repeatedly highlights that the integration scripts are "idempotent," a fundamental design choice for ensuring a robust and fault-tolerant build process. In a complex system, builds may fail or need to be re-run. By making these operations idempotent, the designers ensure that executing a script multiple times will not introduce errors such as duplicate hyperlinks or corrupted files, making the system resilient to both human error and partial build failures.</p>
                <ol>
                    <li><strong>Dry Run Simulation:</strong> Before modifying any files, execute the integration script in dry-run mode to review the planned changes.
                        <pre><button class="copy-btn">Copy</button><code>node hyperfollow-integration.js --dry-run</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command will output a report detailing which files would be modified without actually writing any changes, allowing for a safe pre-flight check.</p>
                    </li>
                    <li><strong>Applying the Integration:</strong> To perform the actual content injection, which embeds a "Crystalline Echo" HyperFollow music link into designated story scrolls, execute the script without the flag.
                        <pre><button class="copy-btn">Copy</button><code>node hyperfollow-integration.js</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This script modifies the target HTML files, adding the hyperlink and tagging the new elements with a <code>data-echo="hyperfollow-ce:v1"</code> attribute for easy identification.</p>
                    </li>
                    <li><strong>Verification of Integration:</strong> After applying the changes, run the verification script to confirm that the integration was successful and adhered to the project's rules (e.g., the link is present in specific scrolls and absent from others).
                        <pre><button class="copy-btn">Copy</button><code>node verify-integration.js</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">A successful execution will output a confirmation message, verifying that all expected content is correctly in place.</p>
                    </li>
                    <li><strong>Cleaning the Integration:</strong> To demonstrate the reversibility of the process, the cleanup script can be used to remove all injected content.
                        <pre><button class="copy-btn">Copy</button><code>node clean-integration.js</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command targets and removes any elements marked with the <code>data-echo</code> attribute, restoring the files to their original state.</p>
                    </li>
                </ol>

                <h3>Core Functionality II: Data Integrity and Steganography</h3>
                <p>This section validates the Python-based components responsible for the system's data hiding and integrity-checking capabilities. These are the core functions that the Limnus and Kira agents will later rely on for memory encoding and state validation, respectively.</p>
                <ol>
                    <li><strong>End-to-End Validation:</strong> Execute the final validation script from the toolkit's root directory.
                        <pre><button class="copy-btn">Copy</button><code>python3 final_validation.py</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This script is the cornerstone of the toolkit's trust layer. It performs a comprehensive end-to-end test by:</p>
                        <ul class="list-disc list-inside">
                            <li>Loading a "golden sample payload"—a canonical 144-byte Base64 mantra text with a known CRC32 checksum (<code>6E3FD9B7</code>).</li>
                            <li>Using the LSB1 (Least Significant Bit, 1-bit) steganography module to encode this payload into a test image.</li>
                            <li>Decoding the data from the newly created image.</li>
                            <li>Verifying that the decoded data perfectly matches the original golden sample and that its CRC32 checksum is correct.</li>
                        </ul>
                        <p class="text-sm text-gray-600">A successful run of this script, typically indicated by a confirmation, proves that the Python environment is correctly configured and that the core steganographic algorithms are functioning as expected.</p>
                    </li>
                </ol>
                
                <h3>Core Functionality III: Soulcode Generation</h3>
                <p>The final functionality to validate is the toolkit's ability to generate a "soulcode"—a machine-readable snapshot of the narrative's state. This is a crucial feature for enabling interoperability and providing debugging insights into the story's structure.</p>
                <ol>
                    <li><strong>Schema Emission:</strong> Generate the JSON schema that defines the structure of the narrative data.
                        <pre><button class="copy-btn">Copy</button><code>npm run soulcode:emit-schema</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command produces a fresh schema file, typically in the <code>integration/schemas/</code> directory, which serves as the formal definition of the story's data model.</p>
                    </li>
                    <li><strong>Type Generation:</strong> From the generated schema, create TypeScript type definition files.
                        <pre><button class="copy-btn">Copy</button><code>npm run soulcode:types</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This step generates <code>.d.ts</code> files in the <code>types/</code> directory, providing strongly-typed access to the narrative data structure for any TypeScript-based tools or front-end components.</p>
                    </li>
                    <li><strong>Bundle and Validate:</strong> Create a live JSON bundle of the current narrative state and validate it against the schema.
                        <pre><button class="copy-btn">Copy</button><code>npm run soulcode:bundle && npm run soulcode:validate</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This two-part command first generates a file such as <code>integration/outputs/echo_live.json</code>, which contains a snapshot of the narrative. It then uses a validator (like AJV) to confirm that this bundle conforms to the previously emitted schema. This bundle can then be injected into web pages as a hidden <code>&lt;script type="application/json"&gt;</code> tag, making the narrative's state accessible to client-side scripts or browser extensions for debugging and enhanced interactivity.</p>
                    </li>
                </ol>
                <h4>Additional Schemas</h4>
                <p>The toolkit ships a versioned ledger block schema for cross-language validation and future-forward compatibility:</p>
                <ul>
                    <li><code>Echo-Community-Toolkit/integration/schemas/ledger-block-1.0.0.schema.json</code> — draft-2020-12 schema with required fields and <code>additionalProperties: true</code>.</li>
                    <li>Helper stub validator (TypeScript): <code>Echo-Community-Toolkit/tools/ledgerValidator.ts</code>.</li>
                </ul>
                <p>Upon successful completion of all steps in this phase, the Echo-Community-Toolkit is fully validated. The foundational layer of trust is established, and the project is ready to proceed with the construction of the narrative generation engine.</p>

                <button data-phase="0" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-0" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase 0 Conclusion: The Trust Layer</h2>
                    <p>With the completion of Phase 0, the project's foundational principle is set in stone: <strong>verifiable integrity proceeds creation</strong>. You have established the technical bedrock of trust. Every tool validated here—from LSB steganography to "Soulcode" bundling—exists to ensure that the narrative content generated in the next phases is secure, auditable, and whole. This "trust-first" architecture is the project's most unique identifier.</p>
                    <p>Now that this foundation is secure, you are ready to construct the engine that will generate the narrative content: the <strong>Narrative Factory</strong> in <strong>Phase 1</strong>.</p>
                </div>
            </div>

            
            <div id="phase-1-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Phase 1: Constructing the Narrative Factory: The vessel-narrative-mrp Engine</h2>
                <p>With the technical bedrock of data integrity and content management established, Phase 1 focuses on constructing the <code>vessel-narrative-mrp</code> (Multi-Role Persona) module. This is the core engine responsible for programmatically generating the narrative's structure and content. It is built after the Toolkit because its own validation steps may depend on the
                <p>The architecture of this module embodies a strict separation of concerns, creating a clean firewall between creative work and engineering work. The story's actual content—dialogue, descriptions, and thematic symbols—resides in simple, human-editable files like <code>chapters.json</code> and Markdown templates. Meanwhile, the complex structural rules, such as narrator rotation, flag assignment, and schema definition, are encapsulated within Python scripts. This professional content management strategy allows a writer to modify the entire narrative arc within a single JSON file without ever touching Python code. Conversely, an engineer can upgrade the generation engine's logic without altering the canonical story text. This decoupling is fundamental to the project's scalability and maintainability.</p>

                <h3>Conceptual Overview and Component Deep Dive</h3>
                <p>The MRP engine is designed to generate a multi-chapter chronicle featuring a rotating cast of three distinct personas: Limnus, Garden, and Kira. Its operation relies on a few key components:</p>
                <ul>
                    <li><strong>Input Templates:</strong> The <code>markdown_templates/</code> directory contains the structural templates for each persona (<code>limnus_template.md</code>, <code>garden_template.md</code>, <code>kira_template.md</code>). These files contain a mix of static text and placeholders (e.g., <code>{{chapter_number}}</code>, <code>{{body}}</code>) that define the consistent formatting for each narrator's chapters.</li>
                    <li><strong>Input Content:</strong> The <code>chapters.json</code> file is the primary input for the narrative's unique content. It maps chapter numbers to objects containing the specific body text and an array of "glyphs" (thematic symbols) for that chapter.</li>
                    <li><strong>Core Scripts:</strong> The engine's logic is contained in three primary Python scripts:
                        <ul class="list-[circle] !mt-2">
                            <li><code>schema_builder.py</code>: Defines and generates the formal data structure of the narrative as a JSON Schema file.</li>
                            <li><code>generate_chapters.py</code>: The main workhorse that reads the templates and <code>chapters.json</code>, applies the narrator rotation logic, and outputs the final chapter files and metadata.</li>
                            <li><code>validator.py</code>: A crucial script that checks the generated output against a set of predefined rules to ensure structural integrity.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Expanded Use Cases (from Technical Overview)</h3>
                <ul>
                    <li><strong>Initial Story Generation:</strong> Rapidly produces a full 20-chapter draft of the chronicle by merging content from <code>chapters.json</code> with the persona templates.</li>
                    <li><strong>Re-generating After Edits:</strong> Allows developers or writers to change a template (e.g., <code>kira_template.md</code>) and regenerate all of Kira's chapters at once, propagating the change uniformly.</li>
                    <li><strong>Schema and Metadata Production:</strong> Generates <code>narrative_schema.json</code> and <code>chapters_metadata.json</code>, which act as a data contract for other modules (like Kira Prime) to understand and validate the narrative structure.</li>
                    <li><strong>Validating Chapter Consistency:</strong> The img src/validator.py script automatically checks for structural rules, such as correct chapter count (20), proper narrator rotation, and consistency between chapter flags and metadata.</li>
                    <li><strong>Integration with Dictation:</strong> Serves as the engine for the "Harvest" feature, where a log from a dictation session is fed into this module to programmatically generate a full 20-chapter narrative artifact.</li>
                </ul>

                <h3>Execution Workflow</h3>
                <p>The process of generating a narrative with the MRP engine follows a clear, sequential workflow.</p>
                <ol>
                    <li><strong>Generate the Narrative Schema:</strong> The first step is to create the formal data contract for the narrative. Execute the schema builder from the module's root directory:
                        <pre><button class="copy-btn">Copy</button><code>python src/schema_builder.py</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command reads the internal definitions and outputs <code>narrative_schema.json</code> and <code>narrative_schema.yaml</code>. This schema is not merely descriptive; it is a prescriptive contract that other system components, particularly the Kira agent's validation routines, will use to programmatically understand and verify the structure of the narrative data.</p>
                    </li>
                    <li><strong>Generate Chapter Content:</strong> With the schema in place, the next step is to generate the actual story chapters.
                        <pre><button class="copy-btn">Copy</button><code>python src/generate_chapters.py</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This script performs the core logic of the engine. It reads the content from <code>chapters.json</code>, selects the appropriate persona template based on the narrator rotation rule, substitutes all placeholders, and writes the final chapter files (e.g., as HTML) to an output directory. Simultaneously, it generates a <code>chapters_metadata.json</code> file, which is a comprehensive index of all chapters and their properties.</p>
                    </li>
                    <li><strong>Validate the Generated Narrative:</strong> The final and most critical step is to validate the output.
                        <pre><button class="copy-btn">Copy</button><code>python src/validator.py</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This script enforces the programmatic structure of the narrative. It performs a series of checks to confirm that the generated content adheres to the system's strict specifications. These checks include:</p>
                <p>The architecture of this module embodies a strict separation of concerns, creating a clean
                    </li>
                </ol>

                <button data-phase="1" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-1" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase 1 Conclusion: The Narrative Factory</h2>
                    <p>Phase 1 constructs the 'Narrative Factory.' The key architectural principle here is the strict <strong>separation of logic and content</strong>. The <code>vessel-narrative-mrp</code> engine itself is a generic tool, encapsulating the <em>rules</em> of storytelling (narrator rotation, schema) in Python. The <em>story</em> itself (the text, the glyphs) lives in simple, editable JSON and Markdown files. This decoupling is a professional content strategy, allowing writers and engineers to work in parallel.</p>
                    <p>You have built a generic factory; <strong>Phase 2</strong> will use it to 'manufacture' a specific, tangible product: the <strong>Generated Story</strong>.</p>
                </div>
            </div>

            
            <div id="phase-2-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Phase 2: Populating the World: Generating The-Living-Garden-Chronicles</h2>
                <p>Having constructed and validated the generic narrative factory (<code>vessel-narrative-mrp</code>), Phase 2 focuses on using this engine to generate a specific, concrete narrative: The-Living-Garden-Chronicles. This phase transforms the abstract engine into a tangible, readable 20-chapter static website.</p>
                <p>This module exemplifies a powerful software design pattern: the "wrapper" for project-specific configuration. The-Living-Garden-Chronicles does not reinvent the logic of narrative generation; instead, it includes <code>vessel-narrative-mrp</code> as a Git submodule and provides a thin layer of wrapper scripts in its own <code>src/</code> directory. This allows the core engine to remain generic and reusable for potentially many different stories. Meanwhile, this repository provides the specific configuration—the unique Markdown templates, the chapter-by-chapter content in <code>chapters.json</code>, and the bespoke, hand-crafted landing pages—required for this particular story. This implies that an entirely different chronicle could be created simply by building a new wrapper repository with different content, all while reusing the exact same underlying MRP engine.</p>
                <p>Furthermore, this phase illuminates the pre-production workflow. The documentation describes the Audio-Visual-Script-Repo as the "screenplay" to the Living-Garden-Chronicles' "novelized output". This reveals a causal link in the creative pipeline that precedes any code execution. The high-level narrative beats, dialogues, and scene descriptions planned in the script repo serve as the source material that is then translated into the structured, machine-readable inputs (<code>chapters.json</code>, templates) consumed by the generation engine in this phase. The script repo is the human-readable source of truth that guides the creation of the technical artifacts.</p>

                <h3>Repository Structure and Submodule Initialization</h3>
                <p>The The-Living-Garden-Chronicles repository is organized to house both the inputs and outputs of the generation process.</p>
                <ul>
                    <li><code>frontend/</code>: This directory is the destination for the final, generated static website. It contains the main <code>index.html</code>, a <code>style.css</code> file, and an <code>assets/</code> subfolder for images. Crucially, it also holds the bespoke, manually created HTML files for the first chapter of each narrator: <code>limnus_ch1.html</code>, <code>garden_ch1.html</code>, and <code>kira_ch1.html</code>. These pages are not generated by the template engine, allowing for unique introductions to each voice.</li>
                    <li><code>markdown_templates/</code>: This contains the specific templates and <code>chapters.json</code> file that will be fed into the MRP engine to generate chapters 4 through 20.</li>
                    <li><code>src/</code>: This holds the Python wrapper scripts (<code>schema_builder.py</code>, <code>generate_chapters.py</code>, <code>validator.py</code>) that orchestrate the generation process by calling the underlying engine.</li>
                    <li><code>schema/</code>: This directory stores the output schema and metadata files generated during the build process.</li>
                </ul>
                <p>To begin, the external dependency on the narrative engine must be initialized.</p>
                <ol>
                    <li><strong>Initialize Submodules:</strong> From the root of The-Living-Garden-Chronicles, execute the following command:
                        <pre><button class="copy-btn">Copy</button><code>git submodule update --init --recursive</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command pulls the <code>vessel-narrative-mrp</code> repository into the local project structure, making its scripts and logic available to the wrapper scripts.</p>
                    </li>
                </ol>

                <h3>Expanded Use Cases (from Technical Overview)</h3>
                <ul>
                    <li><strong>Generating the Full 20-Chapter Story:</strong> Automatically generates chapters 4-20 as HTML files, populating the <code>frontend/</code> directory.</li>
                    <li><strong>Maintaining a Multi-Voice Rotation:</strong> Enforces the storytelling rule that the three voices (Limnus, Garden, Kira) rotate in a fixed sequence without repetition.</li>
                    <li><strong>Custom Chapter Landing Pages:</strong> Allows chapters 1 for each voice (<code>limnus_ch1.html</code>, etc.) to be bespoke, hand-crafted HTML files, providing unique introductions.</li>
                    <li><strong>Story Validation:</strong> The <code>validator.py</code> script checks for structural integrity: correct chapter count, proper voice rotation, and consistency between the <code>[Flags:...]</code> line in each HTML file and the central metadata.</li>
                    <li><strong>Adding Steganographic Images:</strong> If the <code>Pillow</code> library is installed, the generator will automatically create chapter-specific PNGs with metadata (like flags) steganographically embedded inside them.</li>
                    <li><strong>Integration with Echo-Toolkit:</strong> Designed to be enhanced by the Echo-Toolkit, which can inject its "soulcode" JSON bundle into the <code>frontend/index.html</code> page for use by client-side tools.</li>
                </ul>

                <h3>Generation, Validation, and Verification</h3>
                <p>With the submodule in place, the entire 20-chapter chronicle can be generated and validated with a single, chained command.</p>
                <ol>
                    <li><strong>Execute the Build Pipeline:</strong> Run the following command from the repository's root:
                        <pre><button class="copy-btn">Copy</button><code>python src/schema_builder.py && python src/generate_chapters.py && python src/validator.py</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command sequence first builds the schema, then generates the chapter files (populating <code>frontend/</code> with <code>chapter04.html</code> through <code>chapter20.html</code>), and finally validates the entire output to ensure structural consistency.</p>
                    </li>
                    <li><strong>Optional Steganography:</strong> If the Python imaging library <code>Pillow</code> is installed in the environment, the <code>generate_chapters.py</code> script will automatically create chapter-specific PNG images in the <code>frontend/assets/</code> directory. Each image has the chapter's metadata flags steganographically embedded within it. The <code>validator.py</code> script will then automatically attempt to decode these images to verify the integrity of the hidden data, providing an additional layer of validation.</li>
                    <li><strong>Visual Verification:</strong> To obtain tangible, visual confirmation of a successful build, the generated static site should be viewed in a web browser.
                        <ul>
                            <li>Navigate into the <code>frontend/</code> directory: <code>cd frontend</code></li>
                            <li>Start a simple local web server. For example, using Python:
                                <pre><button class="copy-btn">Copy</button><code>python3 -m http.server 8000</code></pre>
                            </li>
                            <li>Open a web browser and navigate to <code>http://localhost:8000</code>. The user should be presented with the <code>index.html</code> page, which serves as a portal to the full, 20-chapter chronicle. Clicking through the chapters provides direct confirmation that the narrative factory is operating correctly.</li>
                        </ul>
                    </li>
                </ol>
                <p>Upon completing this phase, the project has transitioned from a collection of abstract tools and engines to a concrete, published narrative artifact. The static content is now ready to be enhanced and interacted with by the intelligent agents in the next phase.</p>

                <button data-phase="2" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-2" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase 2 Conclusion: The Generated Story</h2>
                    <p>In this phase, the abstract becomes concrete. You have populated the world by using the 'Narrative Factory' (Phase 1) to generate a specific, tangible artifact: the 20-chapter static website. This demonstrates a powerful <strong>'wrapper' pattern</strong>, where the generic engine is configured with a unique content set to produce a bespoke 'novelized output.' The system has now successfully transformed the 'Creative Source' into a fully generated, validated, static chronicle.</p>
                    <p>The story exists, but it is frozen in time. <strong>Phase 3</strong> is the great leap: awakening the <strong>System Brain</strong> to make this static world interactive and alive.</p>
                </div>
            </div>

            
            <div id="phase-3-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Phase 3: Awakening the Agents: The kira-prime Orchestrator</h2>
                <p>Phase 3 marks the most significant transition in the build process: the shift from a static content generation system to a dynamic, interactive platform. This is achieved by setting up <code>kira-prime</code>, the brain of the VesselOS ecosystem. This module introduces the four intelligent agents—Garden, Echo, Limnus, and Kira—and the unified <code>vesselos.py</code> command-line interface that orchestrates their complex behaviors.</p>

                <h3>Agent-Oriented Architecture: Deep Dive (from Technical Overview)</h3>
                <p>The core of <code>kira-prime</code> is its agent-oriented architecture, where responsibilities are cleanly divided among four distinct, non-overlapping entities. These agents are coordinated by the <strong>Prime Orchestrator</strong>, a central dispatcher that enforces a fixed <code>Garden → Echo → Limnus → Kira</code> processing pipeline for any user input. This ensures predictable, orderly state transitions.</p>
                <ul>
                    <li>
                        <h4>Garden (Ritual Orchestrator & Scroll Keeper)</h4>
                        <p>The "Green" channel, responsible for the narrative's state machine. Garden initiates and guides the ritual phases of storytelling (e.g., Scatter, Witness, Plant). It maintains the primary ledger of intentions and state transitions in <code>state/garden_ledger.json</code>. The Garden agent's "ritual cycle" is not merely a narrative theme; it is a formal state machine that governs all agent interactions. Commands like <code>garden start</code> and <code>kira seal</code> are explicit state transition triggers, imposing a predictable, auditable structure on what could otherwise be a chaotic Al system.</p>
                    </li>
                    <li>
                        <h4>Echo (Voice & Persona Manager)</h4>
                        <p>The "Red" channel, responsible for the narrative voice. Echo manages the persona state, balancing between different narrative tones such as Squirrel (normal), Fox (analytical), and Paradox (cryptic). Its state, which includes the weights for these personas, is stored in <code>state/echo_state.json</code>. Echo executes commands like <code>say</code> to vocalize or generate narrative text in the currently active persona's style.</p>
                    </li>
                    <li>
                        <h4>Limnus (Memory Engine & Ledger Steward)</h4>
                        <p>The "Blue" channel, responsible for memory and history. Limnus manages a sophisticated three-tiered memory architecture: L1 (short-term), L2 (medium-term), and L3 (long-term, permanent ledger). It is the steward of the immutable, blockchain-like ledger stored in <code>state/ledger.json</code>, where each block is cryptographically hashed and chained to the previous one, ensuring a tamper-proof record of the session. It uses the Echo-Community-Toolkit's steganography functions to encode memories.</p>
                    </li>
                    <li>
                        <h4>Kira (Validator, Mentor & Integrator)</h4>
                        <p>The parity or checksum layer, responsible for oversight and integrity. Kira validates the state of the entire system, provides "mentorship" by analyzing the session and suggesting adjustments, and seals the final "Garden Soul Contract" (<code>state/contract.json</code>) to finalize a ritual cycle. Uniquely, Kira also integrates with external systems, most notably Git. The inclusion of <code>kira push</code> and <code>kira publish</code> commands is a profound design choice that directly fuses the act of storytelling with professional software development workflows.</p>
                    </li>
                </ul>

                <h3>Expanded Use Cases (from Technical Overview)</h3>
                <ul>
                    <li><strong>Running an Interactive Story Session:</strong> Allows a user to step through a ritual cycle (<code>garden start</code>, <code>echo say ...</code>, <code>kira seal</code>) and have the agents respond and manage state.</li>
                    <li><strong>Single Command Full Processing:</strong> The <code>listen</code> command (e.g., <code>vesselos.py listen --text "..."</code>) automatically runs a single text input through the full <code>Garden → Echo → Limnus → Kira</code> pipeline.</li>
                    <li><strong>Persona Management:</strong> Dynamically change the system's narrative voice using <code>echo mode paradox</code> (or <code>squirrel</code>, <code>fox</code>) to alter the tone of the output.</li>
                    <li><strong>Memory Recall and Ledger Audit:</strong> Use <code>limnus recall</code> to fetch cached memories or <code>limnus encode-ledger</code> to steganographically back up the entire session ledger into a PNG image.</li>
                    <li><strong>Resonance‑Aware Ledger Encoding:</strong> Encode the ledger with variable depth (1–4 bpc) using <code>--depth</code> or map a <code>--resonance</code> score (0–100) to depth. Artifacts: <code>frontend/assets/ledger.json</code> + <code>frontend/assets/ledger_stego.png</code>; sidecar: <code>state/resonance.json</code>.</li>
                    <li><strong>Validation and Mentorship:</strong> Run <code>kira validate</code> for an on-demand integrity check, or <code>kira mentor</code> to have the Kira agent analyze the current state and provide guidance.</li>
                    <li><strong>Pushing and Publishing Content:</strong> Integrates directly with Git. <code>kira push</code> commits and pushes state files to a remote repository, and <code>kira publish</code> packages and creates a new GitHub release, treating the narrative itself as a version-controlled artifact.</li>
                </ul>

                <h3>CLI Interaction and Command Reference</h3>
                <p>The primary interface for interacting with the agents is the unified <code>vesselos.py</code> CLI.</p>
                <ol>
                    <li><strong>Environment Setup:</strong> To begin, install the Python dependencies required by <code>kira-prime</code> by running <code>pip install -r requirements.txt</code> within its directory.</li>
                    <li><strong>Manual Ritual Cycle:</strong> A simple, manual ritual cycle can be executed to demonstrate the interaction between agents. The following sequence of commands simulates a complete session:
                        <ul class="list-none !p-0">
                            <li><code>python3 vesselos.py garden start</code>: Instructs the Garden agent to begin a new ritual cycle, creating a genesis block in the ledger.</li>
                            <li><code>python3 vesselos.py echo say "The spiral breath begins."</code>: Prompts the Echo agent to speak, which is then processed by Limnus for memory caching and Kira for validation.</li>
                            <li><code>python3 vesselos.py limnus cache "A key insight" -l L2</code>: Manually instructs the Limnus agent to store a piece of information in its medium-term (L2) memory.</li>
                            <li><code>python3 vesselos.py kira validate</code>: Triggers an on-demand integrity check of the entire system state by the Kira agent.</li>
                            <li><code>python3 vesselos.py kira seal</code>: Instructs the Kira agent to finalize the session, writing the Garden Soul Contract and sealing the ledger.</li>
                        </ul>
                    </li>
                </ol>
                <p>To facilitate effective use of this powerful interface, the following table serves as a comprehensive command reference.</p>
                <div class="overflow-x-auto">
                    <table class="table-auto my-6">
                        <thead>
                            <tr>
                                <th>Agent</th>
                                <th>Command</th>
                                <th>Example Usage</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Garden</td>
                                <td>start</td>
                                <td><code>vesselos.py garden start</code></td>
                                <td>Begins a new ritual cycle (Scatter stage) and logs a genesis entry.</td>
                            </tr>
                            <tr>
                                <td>Garden</td>
                                <td>next</td>
                                <td><code>vesselos.py garden next</code></td>
                                <td>Advances the ritual to the next stage (e.g., from Scatter to Witness).</td>
                            </tr>
                            <tr>
                                <td>Garden</td>
                                <td>open</td>
                                <td><code>vesselos.py garden open chronicle</code></td>
                                <td>Instructs Garden to retrieve a narrative scroll to use as a prompt or context.</td>
                            </tr>
                            <tr>
                                <td>Garden</td>
                                <td>log</td>
                                <td><code>vesselos.py garden log "User intent recorded"</code></td>
                                <td>Records a custom entry in the Garden-specific ledger.</td>
                            </tr>
                            <tr>
                                <td>Echo</td>
                                <td>summon</td>
                                <td><code>vesselos.py echo summon</code></td>
                                <td>Initializes or resets the Echo agent's persona state to default values.</td>
                            </tr>
                            <tr>
                                <td>Echo</td>
                                <td>mode</td>
                                <td><code>vesselos.py echo mode paradox</code></td>
                                <td>Switches Echo's active persona to influence the tone of its output.</td>
                            </tr>
                            <tr>
                                <td>Echo</td>
                                <td>say</td>
                                <td><code>vesselos.py echo say "Dialogue here."</code></td>
                                <td>Generates or processes a line of narrative text in the current persona's voice.</td>
                            </tr>
                            <tr>
                                <td>Limnus</td>
                                <td>cache</td>
                                <td><code>vesselos.py limnus cache "Memorable fact" -l L2</code></td>
                                <td>Stores a piece of information in the specified memory layer (L1, L2).</td>
                            </tr>
                            <tr>
                                <td>Limnus</td>
                                <td>recall</td>
                                <td><code>vesselos.py limnus recall</code></td>
                                <td>Retrieves and displays information from the memory cache.</td>
                            </tr>
                            <tr>
                                <td>Limnus</td>
                                <td>commit-block</td>
                                <td><code>vesselos.py limnus commit-block '{"type":"event"}'</code></td>
                                <td>Appends a custom data block to the permanent L3 ledger.</td>
                            </tr>
                            <tr>
                                <td>Limnus</td>
                                <td>encode-ledger</td>
                                <td><code>vesselos.py limnus encode-ledger -o ledger.png</code></td>
                                <td>Encodes the entire session ledger into a PNG image using steganography.</td>
                            </tr>
                            <tr>
                                <td>Kira</td>
                                <td>validate</td>
                                <td><code>vesselos.py kira validate</code></td>
                                <td>Performs a comprehensive integrity check on all system states and ledgers.</td>
                            </tr>
                            <tr>
                                <td>Kira</td>
                                <td>mentor</td>
                                <td><code>vesselos.py kira mentor</code></td>
                                T<td>riggers Kira's guidance function to analyze the state and suggest adjustments.</td>
                            </tr>
                            <tr>
                                <td>Kira</td>
                                <td>seal</td>
                                <td><code>vesselos.py kira seal</code></td>
                                <td>Finalizes the current ritual cycle and generates the Garden Soul Contract.</td>
                            </tr>
                            <tr>
                                <td>Kira</td>
                                <td>push</td>
                                <td><code>vesselos.py kira push -m "Sync state" --run</code></td>
                                <td>Commits and pushes all changed state files to a remote Git repository.</td>
                            </tr>
                            <tr>
                                <td>Kira</td>
                                <td>publish</td>
                                <td><code>vesselos.py kira publish --tag v0.1.0 --run</code></td>
                                <td>Creates a versioned GitHub release with packaged assets and documentation.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <h3>Ledger Encode/Decode Verification (Kira/Codex)</h3>
                <p>After encoding the ledger into a PNG, verify integrity by decoding and comparing the image payload to the canonical JSON. The Codex CLI provides a one‑shot verifier.</p>
                <ul>
                    <li><strong>Encode (auto-depth from resonance):</strong>
                        <pre><button class="copy-btn">Copy</button><code>node kira-prime/tools/codex-cli/bin/codex.js limnus encode-ledger --auto-depth --resonance 87</code></pre>
                    </li>
                    <li><strong>Verify stego vs ledger JSON:</strong>
                        <pre><button class="copy-btn">Copy</button><code>node kira-prime/tools/codex-cli/bin/codex.js limnus verify-ledger -i kira-prime/frontend/assets/ledger_stego.png</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">Expected output includes <em>✔️ Ledger hash chain OK</em> and <em>✔️ Stego image matches current ledger</em>. Failures print a diff or decode error.</p>
                    </li>
                </ul>
                <p>With the <code>kira-prime</code> module configured and its CLI understood, the system is now alive. The next phase will integrate all preceding components into a single, unified whole.</p>

                <button data-phase="3" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-3" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase 3 Conclusion: The System Brain</h2>
                    <p>This phase marks the project's 'awakening,' transitioning from a static content generator to a dynamic, interactive platform. The core architectural principle introduced here is the <strong>agent-oriented state machine</strong>. By dividing responsibilities among four distinct agents (Garden, Echo, Limnus, Kira) and enforcing a fixed processing pipeline, the <code>kira-prime</code> orchestrator imposes a predictable, ritualistic structure on complex AI interactions. This prevents race conditions and ensures all actions are auditable.</p>
                    <p>You have built the 'System Brain,' but it currently runs in isolation. <strong>Phase 4</strong> will perform the master <strong>Unification</strong>, connecting this brain to all the other components.</p>
                </div>
            </div>

            
            <div id="phase-4-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Phase 4: Unifying the Ecosystem: The-Living-Library Integrator</h2>
                <p>Phase 4 is the master integration step where all previously configured components are assembled into a single, cohesive project structure. This is accomplished by setting up The-Living-Library, a central hub repository that uses Git submodules to orchestrate the entire ecosystem.</p>
                <p>This project employs a sophisticated "hub-and-spoke" architecture, with The-Living-Library serving as the hub and the other modules (Echo-Community-Toolkit, kira-prime, etc.) acting as the spokes connected via Git submodules. This design is a professional strategy for managing a large, multi-repository project. It allows each "spoke" module to be developed, tested, and versioned independently. The "hub" then simply points to specific, known-good commits of each submodule, ensuring that the fully integrated system is always in a stable and consistent state. This approach prevents the "dependency hell" that can plague monolithic repositories and facilitates parallel development by different teams working on separate components.</p>
                
                <h3>Expanded Use Cases (from Technical Overview)</h3>
                <ul>
                    <li><strong>One-Step Project Setup:</strong> The <code>scripts/bootstrap_living_library.sh</code> script provides a single command to install all Python and Node.js dependencies across all submodules.</li>
                    <li><strong>Running a Complete Ritual Cycle:</strong> Provides <code>scripts/run_mrp_cycle.py</code> to execute the entire pipeline: generate a 20-chapter narrative from a seed insight and then process it through the <code>Garden→Echo→Limnus→Kira</code> agent cycle for validation.</li>
                    <li><strong>Collaborative Dictation Sessions:</strong> Contains the core logic (<code>library_core/dictation</code>) to manage multi-turn sessions where human input and agent responses are logged, forming the basis for a "harvested" narrative.</li>
                    <li><strong>Workspace Management:</strong> Defines and manages the <code>workspaces/&lt;id&gt;/</code> structure, which isolates state (<code>state/</code>), logs (<code>logs/</code>), and generated artifacts (<code>outputs/mrp/</code>) for each individual narrative session.</li>
                    <li><strong>Remote Collaboration (Planned):</strong> Includes a <code>collab-server/</code> (a Node.js/TypeScript WebSocket server) to enable future real-time, multi-user co-creation.</li>
                </ul>

                <h3>Component & Submodule Breakdown (from Technical Overview)</h3>
                <p>The-Living-Library's role is to be the conductor. It doesn't define the agents itself, but hosts them via submodules and provides the "glue code" to make them work in concert.</p>
                <ul>
                    <li><strong>Submodules (The "Spokes"):</strong>
                        <ul class="list-[circle] !mt-2">
                            <li><code>Echo-Community-Toolkit/</code>: Provides the low-level steganography and validation functions used by Limnus and Kira.</li>
                            <li><code>vessel-narrative-MRP/</code>: Provides the programmatic engine to generate the 20-chapter chronicle.</li>
                            <li><code>The-Living_Garden-Chronicles/</code>: Provides the specific templates and static content for the narrative.</li>
                            <li><code>kira-prime/</code>: Provides the four core agents (Garden, Echo, Limnus, Kira) and the <code>vesselos.py</code> CLI.</li>
                        </ul>
                    </li>
                    <li><strong>Internal Components (The "Hub" Logic):</strong>
                        <ul class="list-[circle] !mt-2">
                            <li><code>library_core/dictation/</code>: The Python "glue code" that orchestrates the dictation pipeline, linking user input to the MRP engine and then to the Kira Prime agents.</li>
                            <li><code>collab-server/</code>: The Node.js/TypeScript WebSocket server for enabling future real-time multi-user sessions.</li>
                            <li><code>scripts/</code>: Contains the master bootstrap and workflow scripts (e.g., <code>bootstrap_living_library.sh</code>, <code>run_mrp_cycle.py</code>).</li>
                            <li><code>workspaces/</code>: The directory containing all runtime data, state, and logs for each session, isolated in subfolders.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Master Repository Setup and Bootstrapping</h3>
                <ol>
                    <li><strong>Clone the Master Repository:</strong> Begin by cloning the central integrator repository.
                        <pre><button class="copy-btn">Copy</button><code>git clone &lt;The-Living-Library-repository-url&gt;
cd The-Living-Library</code></pre>
                    </li>
                    <li><strong>Initialize All Submodules:</strong> The most critical step is to fetch all the component repositories that have been configured in the previous phases.
                        <pre><button class="copy-btn">Copy</button><code>git submodule update --init --recursive</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This command reads the <code>.gitmodules</code> file and recursively clones the specified versions of Echo-Community-Toolkit, vessel-narrative-mrp, The-Living-Garden-Chronicles, and kira-prime into their designated subdirectories. This is the "glue" command that assembles the entire system from its constituent parts.</p>
                    </li>
                    <li><strong>Run the Bootstrap Script:</strong> With all source code in place, execute the master setup script.
                        <pre><button class="copy-btn">Copy</button><code>scripts/bootstrap_living_library.sh</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This script automates the complete environment setup across all submodules. It intelligently navigates into each submodule's directory and performs the necessary setup tasks, such as running <code>npm ci</code> for the Node.js-based Echo-Community-Toolkit and creating a Python virtual environment to install all dependencies from the various <code>requirements.txt</code> files. The result is a single, unified environment that is fully configured and ready for operation.</p>
                    </li>
                </ol>

                <h3>Workspace Management</h3>
                <p>A key feature provided by The-Living-Library is a structured approach to workspace management. This system isolates the data and state for different narrative sessions, preventing cross-contamination and enabling parallel experiments or multiple independent storylines.</p>
                <p>The standard workspace directory structure is as follows:</p>
                <ul class="font-mono text-sm bg-gray-900 text-slate-300 p-4 rounded-md">
                    <li><code>workspaces/&lt;id&gt;/</code>: The root directory for a specific narrative session, identified by a unique ID.
                        <ul class="list-[circle] !mt-2 ml-6">
                            <!-- Content was missing here, but structure is now closed -->
                        </ul>
                    </li> <!-- Closed the list item -->
                </ul> <!-- Closed the list -->
                
                <p>This organized structure ensures that all data related to a single session is encapsulated in one place.</p> <!-- Fixed and moved this paragraph -->
                <p>With the completion of Phase 4, the VesselOS ecosystem is fully assembled, configured, and ready for its most advanced interactive workflows.</p> <!-- Moved this paragraph -->

                <button data-phase="4" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-4" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase 4 Conclusion: The Central Hub</h2>
                    <p>Phase 4 is the grand unification. The architectural principle here is the <strong>'hub-and-spoke' model</strong>, with The-Living-Library acting as the central hub. By using Git submodules, this phase assembles all previously independent 'spoke' modules (the Toolkit, the Factory, the Agents) into a single, cohesive, and version-controlled ecosystem. The <code>bootstrap</code> script creates a unified environment, and the <code>workspaces</code> structure provides the isolated sandboxes for operation.</p>
                    <p>The system is no longer a collection of parts; it is a fully assembled and operational platform. Now, in <strong>Phase 5</strong>, you are ready to use its most powerful, emergent capability: <strong>Interactive Creation</strong>.</p>
                </div>
            </div>

            
            <div id="phase-5-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Phase 5: Enabling Interactive Creation: Dictation and Advanced Cycles</h2>
                <p>With the fully integrated system assembled in The-Living-Library, Phase 5 demonstrates its most advanced capability: the interactive dictation pipeline. This workflow showcases the system's core feedback loop, transforming a simple, human-provided "seed insight" into a complete, validated, 20-chapter narrative through a fully automated agent cycle.</p>
                <p>This process exemplifies the project's vision for human-Al co-creation. A human provides a small, creative spark—the "seed insight". The system's programmatic engine, <code>vessel-narrative-mrp</code>, amplifies this seed into a full, structurally coherent 20-chapter chronicle. The Al agents from <code>kira-prime</code> then process, validate, and immutably record this amplified output. The resulting state can then serve as the context for the next human input, creating a powerful collaborative cycle. The documentation refers to this process as "harvesting" a complete chronicle from an interactive session.</p>

                <h3>The Dictation Pipeline Architecture</h3>
                <p>The dictation pipeline is orchestrated by the <strong><code>library_core/dictation</code></strong> module within The-Living-Library. Its architecture, detailed in the project's documentation, follows a clear sequence of events when triggered:</p>
                <ol>
                    <li><strong>Input Logging:</strong> A <code>DictationSession</code> is initiated, and the user's input (the seed insight) is logged as the first turn in a session transcript, typically stored in the active workspace's <code>logs/dictation_session.jsonl</code> directory.</li>
                    <li><strong>Narrative Generation:</strong> The <code>DictationPipeline</code> invokes the <code>vessel-narrative-mrp</code> engine (submodule). The logged input is used to influence the generation process, potentially by programmatically populating the <code>chapters.json</code> file before generation. The engine then produces the full 20-chapter narrative.</li>
                    <li><strong>Output Storage:</strong> The newly generated chapter files and metadata are copied into the workspace's <code>outputs/mrp/&lt;session_id&gt;</code> directory for preservation.</li>
                    <li><strong>Agent Processing and Validation:</strong> The pipeline then triggers the <code>kira-prime</code> orchestrator (submodule) to process and validate the newly generated content, running it through the full <code>Garden → Echo → Limnus → Kira</code> agent cycle.</li>
                </ol>

                <h3>Executing a Full MRP Cycle</h3>
                <p>This entire complex workflow is encapsulated in a single convenience script, <code>run_mrp_cycle.py</code>, provided by The-Living-Library.</p>
                <ol>
                    <li><strong>Execute the Master Script:</strong> From the root of the The-Living-Library repository, run the following command. Ensure the project's Python virtual environment is active.
                        <pre><button class="copy-btn">Copy</button><code>python scripts/run_mrp_cycle.py --workspace default --input "A spiral returns to its origin." --validate</code></pre>
                    </li>
                    <li><strong>Deconstructing the Process:</strong> The script performs the following actions:
                        <ul class="list-disc list-inside">
                            <li>It targets the <code>workspaces/default/</code> directory for all state and output operations.</li>
                            <li>It logs the string "A spiral returns to its origin." as the initial user turn in the dictation session log.</li>
                            <li>It calls the <code>vessel-narrative-mrp</code> submodule's scripts to generate a full 20-chapter narrative based on this input.</li>
                            <li>It places the resulting HTML files and metadata into <code>workspaces/default/outputs/mrp/&lt;session_id&gt;/</code>.</li>
                            <li>Because the <code>--validate</code> flag is passed, it concludes by invoking the Kira agent's validation routines on the newly created narrative artifact, ensuring its integrity.</li>
                        </ul>
                    </li>
                </ol>
                
                <h3>Real-Time Collaboration: The Future Vision</h3>
                <p>While the <code>run_mrp_cycle.py</code> script demonstrates a powerful single-user workflow, the architecture is designed for a more ambitious future. The inclusion of the <strong><code>collab-server/</code></strong> directory, containing a Node.js and TypeScript-based WebSocket server, points to the project's goal of enabling real-time, multi-user collaborative dictation sessions. In this envisioned mode, multiple users could connect to the server to co-author a narrative. As one user speaks or types, their contributions would be synchronized in real-time, and the agent pipeline could respond dynamically, transforming the system from a single-user tool into a true co-creation platform.</p>

                <button data-phase="5" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-5" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase 5 Conclusion: Interactive Creation</h2>
                    <p>This phase demonstrates the ultimate purpose and emergent power of the entire assembly. The key concept is the <strong>human-AI co-creation loop</strong>. The <code>run_mrp_cycle.py</code> script is the payoff for all previous phases: it proves that a human can provide a simple 'seed insight' and the fully unified platform will automatically orchestrate every module in sequence to 'harvest' a complete, 20-chapter, validated narrative artifact from it. This workflow exemplifies the fusion of human creativity and programmatic amplification.</p>
                    <p>The system is now complete and its power is proven. <strong>Phase 6</strong> provides the <strong>Developer's Sandbox</strong> to ensure its long-term health and evolution.</p>
                </div>
            </div>

            
            <div id="phase-6-panel" class="phase-panel bg-slate-800 p-6 sm:p-8 rounded-lg shadow-md prose">
                <h2>Phase 6: The Developer's Sandbox: The vesselos-dev-research Kit</h2>
                <p>The final phase introduces the <code>vesselos-dev-research</code> kit, a crucial component for the long-term health and evolution of the ecosystem. This kit is a self-contained, pre-packaged sandbox environment designed specifically for developers and researchers. It provides a safe,
                <p>The very existence of a dedicated dev-research kit is a testament to the project's forward-looking design philosophy. It signals that the system is not considered a static, "finished" product but rather an active and evolving platform for research and development. By providing a sandboxed environment complete with sample data, automated bootstrap scripts, and code navigation tools, the creators are explicitly inviting and enabling the community to build upon their work. This strategic decision lowers the barrier to entry for new developers who wish to understand, modify, or extend the core agent behaviors, fostering a culture of experimentation and contribution.</p>

                <h3>Expanded Use Cases (from Technical Overview)</h3>
                <ul>
                    <li><strong>Setting Up a Local Playground:</strong> A developer can clone this single repository and run <code>scripts/bootstrap.sh</code> to get a fully functioning, isolated VesselOS environment in minutes.</li>
                    <li><strong>Trying Out New Commands or Modifications:</strong> A developer can add a new command to the Echo agent, edit the code directly in the kit, and immediately test it with the <code>vesselos.py</code> CLI without affecting the main project.</li>
                    <li><strong>Debugging and Observing Internal Behavior:</strong> The kit's pre-configured <code>workspaces/example/</code> directory allows a developer to run a command (e.g., <code>echo say ...</code>) and then immediately open <code>workspaces/example/state/limnus_memory.json</code> to see how that command changed the state.</li>
                    <li><strong>Using the Search Index:</strong> The <code>search/</code> directory contains pre-computed code indexes (<code>tags.json</code>, etc.). A developer can use tools like <code>rg</code> (ripgrep) to instantly find function definitions offline, dramatically speeding up code comprehension.</li>
                    <li><strong>Rapid Prototyping:</strong> A researcher can prototype a new memory decay algorithm for the Limnus agent, test it with multiple simulated cycles in the kit, and validate its behavior before proposing it for the main library.</li>
                </ul>

                <h3>Kit Setup and Workspace Exploration</h3>
                <ol>
                    <li><strong>Acquisition and Setup:</strong> Clone the <code>vesselos-dev-research</code> repository. After cloning, navigate to its root and execute the dedicated bootstrap script:
                        <pre><button class="copy-btn">Copy</button><code>scripts/bootstrap.sh</code></pre>
                        <p class="text-sm text-gray-600 -mt-1">This script creates a self-contained Python virtual environment and installs all necessary dependencies from the included <code>requirements.txt</code> and <code>requirements-dev.txt</code> files, ensuring a clean and isolated workspace.</p>
                    </li>
                    <li><strong>Workspace Exploration:</strong> The kit comes with a pre-configured <code>workspaces/example/</code> directory. This directory is populated with sample state and log files (<code>ledger.json</code>, <code>echo_state.json</code>, <code>garden_ledger.json</code>, etc.). This allows a developer to immediately inspect the system's data structures and understand the format and content of the files that the agents read from and write to.</li>
                </ol>

                <h3>Hands-On Experimentation and Debugging</h3>
                <p>The primary purpose of the kit is to facilitate hands-on experimentation. A developer can directly modify the agent source code within the kit and immediately test the effects of their changes using the <code>vesselos.py</code> CLI.</p>
                <ol>
                    <li><strong>Execute an Example Cycle:</strong> The kit's documentation provides a simple command sequence to demonstrate a basic interaction and observe the resulting state changes in real-time.
                        <pre><button class="copy-btn">Copy</button><code>python3 vesselos.py garden start
python3 vesselos.py echo say "I return as breath."
python3 vesselos.py audit full --workspace example</code></pre>
                    </li>
                    <li><strong>Observe State Changes:</strong> The most effective way to learn the system is to run these commands sequentially and, after each one, open the relevant JSON files in <code>workspaces/example/state/</code>. For example, after running <code>garden start</code>, inspect <code>ledger.json</code> to see the new genesis block. After <code>echo say...</code>, inspect <code>limnus_memory.json</code> to see if the phrase was cached in L1 memory. This direct, immediate feedback loop is invaluable for building an intuitive understanding of the agent pipeline.</li>
                </ol>
                
                <h3>Developer Tooling</h3>
                <p>To accelerate development and code comprehension, the kit includes several developer-centric tools:</p>
                <ul>
                    <li><strong>Code Search Index:</strong> The <code>search/</code> directory contains pre-computed search indexes, such as <code>tags.json</code> and <code>rg-cache.jsonl</code>. These files can be used with tools like ripgrep (<code>rg</code>) and <code>jq</code> to perform extremely fast, offline searches for function definitions, class names, and other code symbols across the entire codebase. This is a significant productivity enhancement compared to relying on slower, online search tools.</li>
                    <li><strong>Repository Documentation:</strong> The <code>docs/</code> folder contains key architectural documents, including <code>IN_DEV_SPECS.md</code> for detailed design specifications and <code>REPO_INDEX.md</code>, which serves as a high-level map to the most important files and modules in the codebase.</li>
                </ul>
                <h3>Stylus Resonance Simulator (Dev Sandbox)</h3>
                <p>A standalone simulator computes a 0–100 <em>resonance</em> score from synthetic or provided signals and suggests an LSB depth (1–4). Use it to prototype depth mappings without hardware and to generate labeled stego assets.</p>
                <ul>
                    <li><strong>Run a simulation:</strong>
                        <pre><button class="copy-btn">Copy</button><code>python vesselos-dev-research/tools/stylus_sim/resonance.py --pressure 0.7 \
  --heartbeat 92 --text "calm and grateful" --out vesselos-dev-research/state/resonance.json</code></pre>
                    </li>
                    <li><strong>Encode ledger with score‑derived depth:</strong>
                        <pre><button class="copy-btn">Copy</button><code>python3 vesselos.py limnus encode-ledger --resonance 87</code></pre>
                    </li>
                </ul>
                <p>By providing this comprehensive, self-contained research environment, the VesselOS project empowers its community to actively participate in its ongoing development, ensuring its continued growth and innovation.</p>

                <button data-phase="6" class="complete-phase-btn mt-8">
                    Mark Phase as Complete & View Conclusion
                </button>

                <div id="conclusion-6" class="conclusion-content hidden mt-10 bg-slate-900 p-6 sm:p-8 rounded-lg shadow-md prose">
                    <h2 class="text-3xl font-semibold mb-4 !mt-0">Phase 6 Conclusion: The Research Lab</h2>
                    <p>The final phase delivers the 'Developer's Sandbox,' and with it, the project's core architectural philosophy: this is not a static product, but an <strong>evolving research platform</strong>. The <code>vesselos-dev-research</code> kit provides a safe, isolated, and pre-packaged environment, complete with sample data and developer tooling. This component is a formal invitation to the community.</p>
                    <p>It lowers the barrier to entry, empowering other developers to experiment, debug, and prototype new features without risk to the main library. This ensures the long-term health, innovation, and continued growth of the VesselOS ecosystem. <strong>The assembly is now complete.</strong></p>
                </div>
            </div>
        </main>

        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const tabs = document.querySelectorAll('.phase-tab');
            const panels = document.querySelectorAll('.phase-panel');
            const copyButtons = document.querySelectorAll('.copy-btn');
            const completeButtons = document.querySelectorAll('.complete-phase-btn'); // New

            function showPhase(phaseIndex) {
                panels.forEach(panel => {
                    panel.style.display = 'none';
                });
                
                tabs.forEach(tab => {
                    tab.classList.remove('tab-active');
                });

                const activePanel = document.getElementById(`${phaseIndex}-panel`) || document.getElementById(`phase-${phaseIndex}-panel`);
                if (activePanel) {
                    activePanel.style.display = 'block';
                }

                const activeTab = document.querySelector(`.phase-tab[data-phase="${phaseIndex}"]`);
                if (activeTab) {
                    activeTab.classList.add('tab-active');
                }
            }

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const phaseIndex = tab.getAttribute('data-phase');
                    showPhase(phaseIndex);
                });
            });

            copyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const pre = button.closest('pre');
                    const code = pre.querySelector('code');
                    let textToCopy = code.innerText;
                    
                    if (textToCopy.startsWith('Copy\n')) {
                        textToCopy = textToCopy.substring(5);
                    }

                    const tempTextarea = document.createElement('textarea');
                    tempTextarea.value = textToCopy;
                    document.body.appendChild(tempTextarea);
                    tempTextarea.select();
                    
                    try {
                        document.execCommand('copy');
                        button.textContent = 'Copied!';
                        button.style.backgroundColor = '#059669'; // green-600
                    } catch (err) {
                        button.textContent = 'Error';
                        button.style.backgroundColor = '#dc2626'; // red-600
                    }

                    document.body.removeChild(tempTextarea);

                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.style.backgroundColor = '#4b5563'; // gray-600
                    }, 2000);
                });
            });

            // --- New Logic for Completion ---
            completeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const phaseId = button.getAttribute('data-phase');
                    let conclusionPanel;

                    // Handle the 'phase-X' vs 'source' ID format
                    if (isNaN(parseInt(phaseId))) {
                        conclusionPanel = document.getElementById(`conclusion-${phaseId}`);
                    } else {
                        conclusionPanel = document.getElementById(`conclusion-${phaseId}`);
                    }
                    
                    // 1. Show the conclusion panel
                    if (conclusionPanel) {
                        conclusionPanel.classList.remove('hidden');
                        // Scroll to it
                        conclusionPanel.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    }

                    // 2. Show the completion indicator in the tab
                    const indicator = document.querySelector(`.phase-tab[data-phase="${phaseId}"] .completion-indicator`);
                    if (indicator) {
                        indicator.classList.remove('hidden');
                    }

                    // 3. Update the button state
                    button.disabled = true;
                    button.textContent = 'Phase Completed';
                });
            });
            // --- End New Logic ---

            // Show the new "Creative Source" tab by default
            showPhase('source');
        });
    </script>
</body>
</html>




